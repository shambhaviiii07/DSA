problem link----> lintcode.com/problem/516/
problem linl---->https://leetcode.com/problems/minimum-falling-path-sum-ii/

Approach 1:Brute Force   [TLE for LintCode]
class Solution:
    """
    @param costs: n x k cost matrix
    @return: an integer, the minimum cost to paint all houses
    """
    def minCostII(self, costs):
        # write your code here
        if len(costs)==0:
            return 0
        k=len(costs[0])
        for i in range(1,len(costs)):
            for j in range(k):
                min_cost=math.inf
                for m in range(k):
                    if j!=m:
                        min_cost=min(min_cost,costs[i-1][m])
                costs[i][j]+=min_cost
        return min(costs[-1])
        
 PS: will work for Paint House I also.
 
 
 Approach 2:Dynamic Programming
import math
class Solution:
    def minFallingPathSum(self, grid: List[List[int]]) -> int:
        if len(grid)==0:
            return 0
        n=len(grid)
        min_value=math.inf
        s_min_value=math.inf #second minimum value
        for i in range(n):
            curr_value=grid[0][i]
            if curr_value<min_value:
                s_min_value=min_value
                min_value=curr_value
            elif curr_value<s_min_value:
                s_min_value=curr_value
        for i in range(1,n):
            new_min_val=math.inf
            new_s_min_val=math.inf
            for j in range(n):
                if grid[i-1][j]!=min_value:
                    grid[i][j]+=min_value
                else:
                    grid[i][j]+=s_min_value
                if grid[i][j]<new_min_val:
                    new_s_min_val=new_min_val
                    new_min_val=grid[i][j]
                elif grid[i][j]<new_s_min_val:
                    new_s_min_val=grid[i][j]
            min_value=new_min_val
            s_min_value=new_s_min_val
        return min(grid[-1])
