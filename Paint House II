problem link----> lintcode.com/problem/516/
problem linl---->https://leetcode.com/problems/minimum-falling-path-sum-ii/

Approach 1:Brute Force   [TLE for LintCode]
class Solution:
    """
    @param costs: n x k cost matrix
    @return: an integer, the minimum cost to paint all houses
    """
    def minCostII(self, costs):
        # write your code here
        if len(costs)==0:
            return 0
        k=len(costs[0])
        for i in range(1,len(costs)):
            for j in range(k):
                min_cost=math.inf
                for m in range(k):
                    if j!=m:
                        min_cost=min(min_cost,costs[i-1][m])
                costs[i][j]+=min_cost
        return min(costs[-1])
        
 PS: will work for Paint House I also.
 
 
 Approach 2:Dynamic Programming
import math
class Solution:
    def minCostII(self, costs):
        if len(costs)==0:
            return 0
        k=len(costs[0])
        min_value=math.inf
        s_min_value=math.inf  #second minimum
        for i in range(k):
            curr_value=costs[0][i]
            if curr_value<min_value:
                s_min_value=min_value
                min_value=curr_value
            elif curr_value<s_min_value:
                s_min_value=curr_value
        for i in range(1,len(costs)):
            new_min=math.inf
            new_s_min=math.inf
            for j in range(len(costs[0])):
                if costs[i-1][j]!=min_value:
                    costs[i][j]+=min_value
                else:
                    costs[i][j]+=s_min_value
                if costs[i][j]<new_min:
                    new_s_min=new_min
                    new_min=costs[i][j]
                elif costs[i][j]<new_s_min:
                    new_s_min=costs[i][j]
            min_value=new_min
            s_min_val=new_s_min
        return min(costs[-1])
